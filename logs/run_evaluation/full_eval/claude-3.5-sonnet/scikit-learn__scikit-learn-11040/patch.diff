
--- a/sklearn/neighbors/base.py
+++ b/sklearn/neighbors/base.py
@@ -56,6 +56,24 @@
                          "'distance', or a callable function")
 
 
+def _check_n_neighbors(n_neighbors):
+    """Check to make sure n_neighbors is a valid integer"""
+    if n_neighbors is None:
+        return n_neighbors
+    
+    # Check if it's already an integer type
+    if isinstance(n_neighbors, (int, np.integer)):
+        return int(n_neighbors)
+    
+    # Check if it's a float that represents an integer
+    if isinstance(n_neighbors, (float, np.floating)):
+        if n_neighbors.is_integer():
+            return int(n_neighbors)
+        else:
+            raise ValueError("n_neighbors must be an integer, got %r" % n_neighbors)
+    
+    raise ValueError("n_neighbors must be an integer, got %r" % n_neighbors)
+
+
 def _get_weights(dist, weights):
     """Get the weights from an array of distances and a parameter ``weights``
 
@@ -253,6 +271,7 @@
                              % self.algorithm)
 
         if self.n_neighbors is not None:
+            self.n_neighbors = _check_n_neighbors(self.n_neighbors)
             if self.n_neighbors <= 0:
                 raise ValueError(
                     "Expected n_neighbors > 0. Got %d" %
@@ -327,6 +346,7 @@
 
         if n_neighbors is None:
             n_neighbors = self.n_neighbors
+        n_neighbors = _check_n_neighbors(n_neighbors)
 
         if X is not None:
             query_is_train = False
@@ -466,6 +486,7 @@
         """
         if n_neighbors is None:
             n_neighbors = self.n_neighbors
+        n_neighbors = _check_n_neighbors(n_neighbors)
 
         # kneighbors does the None handling.
         if X is not None:
